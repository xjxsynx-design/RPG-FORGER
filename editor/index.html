<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>RPG Forgeworks — Editor</title>
<style>
:root{
  --font-ui: system-ui,-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Arial,sans-serif;
  --font-accent: Chalkduster,'Chalkboard SE','Marker Felt','Bradley Hand',cursive;

  /* Forgeworks Theme */
  --bg:#000000;
  --panel:#111317;
  --panel-2:#161b22;

  --text:#e7e7ea;
  --muted:#b6b8c0;

  --steel:#2e3440;
  --steel-border:#6b7280;

  --ember:#c2410c;
  --ember-hover:#ea580c;

  --earth:#4d7c59;

  --select:#22ff66;           /* selection outline neon green */
  --warn:#f97316;             /* forge orange for warnings/modals */

  --grid-normal:#64748b;      /* slate blue-gray default */
  --grid-high:#8fa3b8;
  --grid: var(--grid-normal);
}
*{box-sizing:border-box}
body{margin:0;background:var(--bg);color:var(--text);font-family:var(--font-ui)}
#topbar .spacer{flex:1}
button{background:var(--steel);border:1px solid var(--steel-border);border-radius:12px;color:var(--text);padding:8px 12px;font-size:13px;white-space:nowrap;font-family:var(--font-accent)}
button:hover{filter:brightness(1.05)}
button.primary,#saveBtn{background:var(--ember);border-color:transparent;color:#fff7ed}
button.primary:hover,#saveBtn:hover{background:var(--ember-hover)}
button.secondary{background:transparent;border:1px solid var(--steel-border);color:var(--text)}
button.active{background:var(--earth);border-color:transparent;outline:2px solid var(--select)}

#toolbar{
 display:flex;gap:8px;padding:8px;background:#120b22;
 border-bottom:1px solid var(--stroke);
 overflow-x:auto;white-space:nowrap
}
#toolbar button{flex-shrink:0}
#toolbar button.active{outline:2px solid var(--neon);}


canvas{display:block;touch-action:none}

/* --- View select modal (mandatory on first open) --- */
#viewModalBack{position:fixed;inset:0;background:rgba(0,0,0,.55);
 display:none;align-items:center;justify-content:center;padding:18px;z-index:50}
#viewModal{width:min(520px,100%);background:var(--panel);border:1px solid var(--stroke);
 border-radius:18px;padding:16px}
#viewModal h3{margin:0 0 6px 0}
#viewModal p{margin:0 0 12px 0;opacity:.9;line-height:1.35}
#viewModal .row{display:flex;gap:10px;flex-wrap:wrap}
#viewModal .row button{flex:1;min-width:140px}
#viewModal .note{margin-top:10px;font-size:12px;opacity:.85}

#phaseLabel{
 position:fixed;left:50%;bottom:6px;transform:translateX(-50%);
 color:#7bffcc;font-weight:700;letter-spacing:.08em;
 text-shadow:0 0 6px rgba(123,255,204,.6)
}

/* Typography system: UI vs Accent */
h1,h2,h3,
button,.btn,.primary,.secondary,
.modal h3,.modal h2,.modal-title,
.toast,.pill,.label,.header-title{
  font-family: var(--font-accent);
  letter-spacing: 0.02em;
}
input,select,textarea,small,p,li,span,div{
  font-family: var(--font-ui);
}
.hidden{display:none!important}
#viewModalBack{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,.6)}
#viewModal{background:var(--panel-2);border:1px solid var(--steel-border);border-radius:16px;padding:16px;max-width:420px;width:92%;box-shadow:0 8px 30px rgba(0,0,0,.4)}
#viewModal h3{margin:0 0 8px 0;color:var(--warn);font-family:var(--font-accent)}
#viewModal p{margin:0 0 12px 0;color:var(--text);font-family:var(--font-ui)}
#viewModal .note{margin-top:12px;color:var(--warn);font-size:12px;line-height:1.2;font-family:var(--font-ui)}


/* =========================
   THEME TOKENS (Forgeworks)
========================= */
:root{
  --bg:#07060b;
  --panel:#150f28;
  --panel2:#120b22;
  --steel:#5b6775;
  --ember:#f08a2b;
  --earthy:#4c8a5a; /* active tool */
  --neon:#37ff6b;   /* selection outline */
  --grid:#495a78;   /* slate blue-gray */
  --gridHi:#8da3c7; /* high contrast */
  --parchment:#f3e6c8;
  --parchment2:#e8d7b2;
  --text:#e9e6f2;
}

body{background:var(--bg); color:var(--text);}

/* Ensure Chalkduster everywhere it matters */
body, button, input, select, .modal{font-family: Chalkduster, "Chalkduster", system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;}

/* Modals */
.backdrop{
  position:fixed; inset:0;
  background: rgba(0,0,0,.55);
  display:flex; align-items:center; justify-content:center;
  padding:16px;
  z-index:9999;
}
.backdrop.hidden{display:none;}
.modal{
  width:min(520px, 92vw);
  max-height: 85vh;
  overflow:auto;
  background: rgba(21,15,40,.92);
  border:2px solid rgba(240,138,43,.45);
  border-radius:18px;
  padding:18px 18px 16px;
  box-shadow: 0 18px 60px rgba(0,0,0,.55);
}
.modal h3{margin:0 0 10px; color:var(--ember); letter-spacing:.5px;}
.modal .muted{opacity:.85; line-height:1.35; margin:0 0 14px;}

</style>
</head>
<body>

<div id="topbar">
 <strong>Editor</strong>
 <div class="spacer"></div>
 <button class="secondary" id="zoomOutBtn">−</button>
      <button class="secondary" id="zoomInBtn">+</button>
      <button class="secondary" id="zoomResetBtn">100%</button>
      <button id="saveBtn">Save</button>
 <button id="gridContrastBtn" class="secondary">Grid: Normal</button>
</div>

<div id="toolbar">
 <button class="active" data-tool="paint">Paint</button>
 <button class="secondary" data-tool="erase">Erase</button>
 <button class="secondary" data-tool="pan">Pan</button>
 <button class="secondary" data-tool="region">Region</button>
 <button class="secondary" data-tool="object">Object</button>
 <button class="secondary" data-tool="music">Music</button>
</div>

<canvas id="canvas"></canvas>

<!-- Mandatory view selection (only shown if this map has no viewMode yet) -->
<div id="viewModalBack">
  <div id="viewModal">
    <h3>Select view for this map</h3>
    <p>This map needs a view mode before editing can begin.</p>
    <div class="row">
      <button id="pickTop">Top</button>
      <button id="pickAngular" class="secondary">Angular</button>
    </div>
    <div class="note">Once selected, this map's view cannot be changed until a new map is created.</div>
  </div>
</div>
<div id="phaseLabel">PATCH C • PHASE 14F.1a</div>

<script>
const active = JSON.parse(localStorage.getItem("rpgdream_active_project")||"null");
if(!active){ location.href="../manager/index.html"; }

// --- Resolve active map (supports older + newer project shapes) ---
const maps = Array.isArray(active.maps) ? active.maps : [];
const activeMapId = active.editor?.activeMapId || (maps[0]?.id);
const activeMap = maps.find(m => m.id === activeMapId) || maps[0] || null;

// Project-level default (older projects) + per-map viewMode (preferred)
let resolvedView = (activeMap?.viewMode || active.data?.view || "").toLowerCase();
if(resolvedView !== "angular" && resolvedView !== "top") resolvedView = "";

// Locking rule: once a map has a viewMode, treat it as permanent.
const viewLocked = !!activeMap?.viewMode;

const viewModalBack = document.getElementById("viewModalBack");
const pickTop = document.getElementById("pickTop");
const pickAngular = document.getElementById("pickAngular");

function saveActive(){
  localStorage.setItem("rpgdream_active_project", JSON.stringify(active));
}

/* -------------------------
   Storage Helpers (Manager-compatible)
------------------------- */
function getProjects() {
  return JSON.parse(localStorage.getItem('rpgdream_projects') || '[]');
}

function saveProjects(projects) {
  localStorage.setItem('rpgdream_projects', JSON.stringify(projects));
}

function upsertProject(project) {
  if (!project || !project.id) return;
  const projects = getProjects();
  const idx = projects.findIndex(p => p.id === project.id);
  if (idx >= 0) projects[idx] = project;
  else projects.unshift(project);
  saveProjects(projects);
}

function toast(msg) {
  try {
    const t = document.createElement('div');
    t.textContent = msg;
    t.style.position = 'fixed';
    t.style.left = '50%';
    t.style.top = '18px';
    t.style.transform = 'translateX(-50%)';
    t.style.padding = '10px 14px';
    t.style.borderRadius = '12px';
    t.style.background = 'rgba(20,20,30,0.85)';
    t.style.border = '1px solid rgba(140,110,255,0.35)';
    t.style.color = '#fff';
    t.style.zIndex = 9999;
    t.style.fontFamily = 'system-ui, -apple-system, Segoe UI, Roboto, sans-serif';
    document.body.appendChild(t);
    setTimeout(() => t.remove(), 1200);
  } catch (e) {}
}

function ensureViewSelected(){
  if(resolvedView){
    viewModalBack.style.display = "none";
    return true;
  }
  // show modal
  viewModalBack.style.display = "flex";
  return false;
}

function commitView(v){
  const vv = v === "angular" ? "angular" : "top";
  resolvedView = vv;
  // set per-map viewMode (preferred)
  if(activeMap){
    activeMap.viewMode = vv;
  }
  // keep project default for backward compat
  active.data = active.data || {};
  active.data.view = vv;
  saveActive();
  viewModalBack.style.display = "none";
  render();
}

pickTop.addEventListener("click", () => commitView("top"));
pickAngular.addEventListener("click", () => commitView("angular"));

ensureViewSelected();

// Save button wiring (updates active project + projects list)
const saveBtn = document.getElementById('saveBtn');
if (saveBtn) {
  saveBtn.addEventListener('click', () => {
    try {
      saveActive();
      upsertProject(active);
      toast('Saved');
    } catch (e) {
      console.error(e);
      alert('Save failed.');
    }
  });
}

const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");



/* -------------------------
   TOOL WIRING (UI)
------------------------- */
let currentTool = "paint";

function setActiveTool(name){
  currentTool = name;
  document.querySelectorAll("#toolbar button").forEach(b=>{
    const t=(b.dataset.tool||"").toLowerCase();
    b.classList.toggle("active", t===name);
  });

  // open modals for tool types that are modal-driven
  if (name === "region") openModal("regionModal");
  if (name === "object") openModal("objectModal");
  if (name === "music") openModal("musicModal");
}

function openModal(id){
  const el=document.getElementById(id);
  if(!el) return;
  el.classList.remove("hidden");
}
function closeModal(id){
  const el=document.getElementById(id);
  if(!el) return;
  el.classList.add("hidden");
}

function wireToolbar(){
  // tag each button by its label once
  document.querySelectorAll("#toolbar button").forEach(btn=>{
    if(!btn.dataset.tool){
      btn.dataset.tool = btn.textContent.trim().toLowerCase();
    }
    btn.addEventListener("click", ()=>{
      const tool = (btn.dataset.tool||"").toLowerCase();
      if(["paint","erase","pan","region","object","music"].includes(tool)){
        setActiveTool(tool);
      }
    });
  });

  // modal close buttons
  document.querySelectorAll("[data-close]").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      closeModal(btn.getAttribute("data-close"));
    });
  });

  // default
  setActiveTool("paint");
}

function drawParchmentBackground(){
  // Fill a parchment-like base so the grid sits on top (prevents white/blank canvas look)
  const g = ctx.createLinearGradient(0,0,0,canvas.height);
  g.addColorStop(0, getComputedStyle(document.documentElement).getPropertyValue("--parchment") || "#f3e6c8");
  g.addColorStop(1, getComputedStyle(document.documentElement).getPropertyValue("--parchment2") || "#e8d7b2");
  ctx.fillStyle = g;
  ctx.fillRect(0,0,canvas.width,canvas.height);
}

const TILE = 32;
let cam = { x:0, y:0, zoom:1 };

function resize(){
 canvas.width = innerWidth;
 canvas.height = innerHeight - 120;
}
window.addEventListener("resize", resize);
resize();

// --- Grid Contrast Toggle ---
let gridHigh = false;
const gridBtn = document.getElementById("gridContrastBtn");
function applyGridContrast(){
  const cs = getComputedStyle(document.documentElement);
  const normal = cs.getPropertyValue('--grid-normal').trim() || '#64748b';
  const high = cs.getPropertyValue('--grid-high').trim() || '#8fa3b8';
  document.documentElement.style.setProperty('--grid', gridHigh ? high : normal);
  if(gridBtn) gridBtn.textContent = gridHigh ? "Grid: High" : "Grid: Normal";
}
if(gridBtn){
  gridBtn.addEventListener("click", ()=>{
    gridHigh = !gridHigh;
    applyGridContrast();
  });
}
applyGridContrast();


function isoToScreen(x,y){
 return {
  x: (x - y) * (TILE/2),
  y: (x + y) * (TILE/4)
 };
}

function drawTopGrid(){
 const step = TILE * cam.zoom;
 ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid');
 for(let x=0;x<canvas.width;x+=step){
  ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); ctx.stroke();
 }
 for(let y=0;y<canvas.height;y+=step){
  ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); ctx.stroke();
 }
}

function drawAngularGrid(){
 ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid');
 const range = 40;
 for(let x=-range;x<=range;x++){
  for(let y=-range;y<=range;y++){
   const p = isoToScreen(x,y);
   ctx.beginPath();
   ctx.moveTo(p.x, p.y - TILE/4);
   ctx.lineTo(p.x + TILE/2, p.y);
   ctx.lineTo(p.x, p.y + TILE/4);
   ctx.lineTo(p.x - TILE/2, p.y);
   ctx.closePath();
   ctx.stroke();
  }
 }
}

function render(){
  const view = (active?.data?.view === "angular") ? "angular" : "top";
 ctx.setTransform(1,0,0,1,0,0);
 ctx.clearRect(0,0,canvas.width,canvas.height);

 ctx.translate(canvas.width/2, canvas.height/2);
 ctx.scale(cam.zoom, cam.zoom);
 ctx.translate(-canvas.width/2 - cam.x, -canvas.height/2 - cam.y);

 if(view === "angular") drawAngularGrid();
 else drawTopGrid();

 requestAnimationFrame(render);
}

// -------------------------
// Zoom (mouse wheel + pinch)
// -------------------------
(function enableZoom(){
  // Wheel zoom (desktop / trackpad)
  canvas.addEventListener("wheel", (e) => {
    e.preventDefault();
    const prev = cam.zoom;
    const factor = e.deltaY < 0 ? 1.12 : 0.90;
    cam.zoom = Math.max(0.5, Math.min(4, cam.zoom * factor));

    // Zoom around cursor so it feels natural
    const rect = canvas.getBoundingClientRect();
    const cx = e.clientX - rect.left;
    const cy = e.clientY - rect.top;

    const worldX = cam.x + (cx / prev);
    const worldY = cam.y + (cy / prev);

    cam.x = worldX - (cx / cam.zoom);
    cam.y = worldY - (cy / cam.zoom);

    render();
  }, { passive: false });

  // Pinch zoom (touch)
  const pts = new Map(); // pointerId -> {x,y}
  let lastDist = null;
  let lastCenter = null;

  function dist(a,b){
    const dx = a.x-b.x, dy = a.y-b.y;
    return Math.hypot(dx,dy);
  }
  function center(a,b){ return { x:(a.x+b.x)/2, y:(a.y+b.y)/2 }; }

  canvas.addEventListener("pointerdown", (e) => {
    if (e.pointerType === "touch") {
      pts.set(e.pointerId, { x: e.clientX, y: e.clientY });
      if (pts.size === 2){
        const [p1,p2] = Array.from(pts.values());
        lastDist = dist(p1,p2);
        lastCenter = center(p1,p2);
      }
    }
  }, { passive: true });

  canvas.addEventListener("pointermove", (e) => {
    if (e.pointerType !== "touch") return;
    if (!pts.has(e.pointerId)) return;

    pts.set(e.pointerId, { x: e.clientX, y: e.clientY });

    if (pts.size === 2){
      const [p1,p2] = Array.from(pts.values());
      const d = dist(p1,p2);
      const c = center(p1,p2);

      if (lastDist){
        const prev = cam.zoom;
        const factor = d / lastDist;
        cam.zoom = Math.max(0.5, Math.min(4, cam.zoom * factor));

        // zoom about pinch center
        const rect = canvas.getBoundingClientRect();
        const cx = c.x - rect.left;
        const cy = c.y - rect.top;

        const worldX = cam.x + (cx / prev);
        const worldY = cam.y + (cy / prev);

        cam.x = worldX - (cx / cam.zoom);
        cam.y = worldY - (cy / cam.zoom);

        render();
      }
      lastDist = d;
      lastCenter = c;
    }
  }, { passive: true });

  function endTouch(e){
    if (e.pointerType !== "touch") return;
    pts.delete(e.pointerId);
    if (pts.size < 2){
      lastDist = null;
      lastCenter = null;
    }
  }
  canvas.addEventListener("pointerup", endTouch, { passive: true });
  canvas.addEventListener("pointercancel", endTouch, { passive: true });
})();

render();

canvas.addEventListener("wheel", e=>{
 e.preventDefault();
 cam.zoom = Math.max(.5, Math.min(3, cam.zoom + (e.deltaY>0?-0.1:0.1)));
},{passive:false});

let panning=false, last={x:0,y:0};
canvas.addEventListener("pointerdown", e=>{
 panning=true; last={x:e.clientX,y:e.clientY};
});
canvas.addEventListener("pointermove", e=>{
 if(panning){
  cam.x += (last.x - e.clientX)/cam.zoom;
  cam.y += (last.y - e.clientY)/cam.zoom;
  last={x:e.clientX,y:e.clientY};
 }
});
canvas.addEventListener("pointerup", ()=>panning=false);
canvas.addEventListener("pointerleave", ()=>panning=false);
</script>

<!-- MODALS -->
<div class="backdrop hidden" id="regionModal">
  <div class="modal">
    <h3>Regions</h3>
    <p class="muted">Tap and drag on the canvas to mark regions (coming next).</p>
    <button class="secondary" data-close="regionModal">Close</button>
  </div>
</div>

<div class="backdrop hidden" id="objectModal">
  <div class="modal">
    <h3>Objects</h3>
    <p class="muted">Place interactables, NPC anchors, and props (coming next).</p>
    <button class="secondary" data-close="objectModal">Close</button>
  </div>
</div>

<div class="backdrop hidden" id="musicModal">
  <div class="modal">
    <h3>Music</h3>
    <p class="muted">Assign BGM / SFX per map or region (coming next).</p>
    <button class="secondary" data-close="musicModal">Close</button>
  </div>
</div>

</body>
</html>