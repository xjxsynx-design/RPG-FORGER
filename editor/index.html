<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>RPG DREAM EDITOR</title>
<style>
:root{
 --bg:#0b0718;--panel:#16102a;--stroke:#3a2b7a;--primary:#7b5cff;
 --text:#efeaff;--white:#ffffff;--grid:#3a2b7a
}
*{box-sizing:border-box}
body{margin:0;background:var(--bg);color:var(--text);
 font-family:system-ui,-apple-system,BlinkMacSystemFont,sans-serif}
#topbar{display:flex;align-items:center;gap:8px;padding:10px;
 background:var(--panel);border-bottom:1px solid var(--stroke)}
#topbar .spacer{flex:1}
button{background:var(--primary);border:none;border-radius:12px;
 color:#fff;padding:8px 12px;font-size:13px;white-space:nowrap}
button.secondary{background:transparent;border:1px solid var(--primary)}
button.active{outline:2px solid #fff}

#toolbar{
 display:flex;gap:8px;padding:8px;background:#120b22;
 border-bottom:1px solid var(--stroke);
 overflow-x:auto;white-space:nowrap
}
#toolbar button{flex-shrink:0}

canvas{display:block;touch-action:none}

/* --- View select modal (mandatory on first open) --- */
#viewModalBack{position:fixed;inset:0;background:rgba(0,0,0,.55);
 display:none;align-items:center;justify-content:center;padding:18px;z-index:50}
#viewModal{width:min(520px,100%);background:var(--panel);border:1px solid var(--stroke);
 border-radius:18px;padding:16px}
#viewModal h3{margin:0 0 6px 0}
#viewModal p{margin:0 0 12px 0;opacity:.9;line-height:1.35}
#viewModal .row{display:flex;gap:10px;flex-wrap:wrap}
#viewModal .row button{flex:1;min-width:140px}
#viewModal .note{margin-top:10px;font-size:12px;opacity:.85}

#phaseLabel{
 position:fixed;left:50%;bottom:6px;transform:translateX(-50%);
 color:#7bffcc;font-weight:700;letter-spacing:.08em;
 text-shadow:0 0 6px rgba(123,255,204,.6)
}
</style>
</head>
<body>

<div id="topbar">
 <strong>Editor</strong>
 <div class="spacer"></div>
 <button id="saveBtn">Save</button>
</div>

<div id="toolbar">
 <button class="active">Paint</button>
 <button class="secondary">Erase</button>
 <button class="secondary">Pan</button>
 <button class="secondary">Region</button>
 <button class="secondary">Object</button>
 <button class="secondary">Music</button>
</div>

<canvas id="canvas"></canvas>

<!-- Mandatory view selection (only shown if this map has no viewMode yet) -->
<div id="viewModalBack">
  <div id="viewModal">
    <h3>Select view for this map</h3>
    <p>This map needs a view mode before editing can begin.</p>
    <div class="row">
      <button id="pickTop">Top</button>
      <button id="pickAngular" class="secondary">Angular</button>
    </div>
    <div class="note">Once selected, this map's view cannot be changed until a new map is created.</div>
  </div>
</div>
<div id="phaseLabel">PHASE 14F.1a</div>

<script>
const active = JSON.parse(localStorage.getItem("rpgdream_active_project")||"null");
if(!active){ location.href="../manager/index.html"; }

// --- Resolve active map (supports older + newer project shapes) ---
const maps = Array.isArray(active.maps) ? active.maps : [];
const activeMapId = active.editor?.activeMapId || (maps[0]?.id);
const activeMap = maps.find(m => m.id === activeMapId) || maps[0] || null;

// Project-level default (older projects) + per-map viewMode (preferred)
let resolvedView = (activeMap?.viewMode || active.data?.view || "").toLowerCase();
if(resolvedView !== "angular" && resolvedView !== "top") resolvedView = "";

// Locking rule: once a map has a viewMode, treat it as permanent.
const viewLocked = !!activeMap?.viewMode;

const viewModalBack = document.getElementById("viewModalBack");
const pickTop = document.getElementById("pickTop");
const pickAngular = document.getElementById("pickAngular");

function saveActive(){
  localStorage.setItem("rpgdream_active_project", JSON.stringify(active));
}

function ensureViewSelected(){
  if(resolvedView){
    viewModalBack.style.display = "none";
    return true;
  }
  // show modal
  viewModalBack.style.display = "flex";
  return false;
}

function commitView(v){
  const vv = v === "angular" ? "angular" : "top";
  resolvedView = vv;
  // set per-map viewMode (preferred)
  if(activeMap){
    activeMap.viewMode = vv;
  }
  // keep project default for backward compat
  active.data = active.data || {};
  active.data.view = vv;
  saveActive();
  viewModalBack.style.display = "none";
  render();
}

pickTop.addEventListener("click", () => commitView("top"));
pickAngular.addEventListener("click", () => commitView("angular"));

ensureViewSelected();

const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

const TILE = 32;
let cam = { x:0, y:0, zoom:1 };

function resize(){
 canvas.width = innerWidth;
 canvas.height = innerHeight - 120;
}
window.addEventListener("resize", resize);
resize();

function isoToScreen(x,y){
 return {
  x: (x - y) * (TILE/2),
  y: (x + y) * (TILE/4)
 };
}

function drawTopGrid(){
 const step = TILE * cam.zoom;
 ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid');
 for(let x=0;x<canvas.width;x+=step){
  ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); ctx.stroke();
 }
 for(let y=0;y<canvas.height;y+=step){
  ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); ctx.stroke();
 }
}

function drawAngularGrid(){
 ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid');
 const range = 40;
 for(let x=-range;x<=range;x++){
  for(let y=-range;y<=range;y++){
   const p = isoToScreen(x,y);
   ctx.beginPath();
   ctx.moveTo(p.x, p.y - TILE/4);
   ctx.lineTo(p.x + TILE/2, p.y);
   ctx.lineTo(p.x, p.y + TILE/4);
   ctx.lineTo(p.x - TILE/2, p.y);
   ctx.closePath();
   ctx.stroke();
  }
 }
}

function render(){
  const view = (active?.data?.view === "angular") ? "angular" : "top";
 ctx.setTransform(1,0,0,1,0,0);
 ctx.clearRect(0,0,canvas.width,canvas.height);

 ctx.translate(canvas.width/2, canvas.height/2);
 ctx.scale(cam.zoom, cam.zoom);
 ctx.translate(-canvas.width/2 - cam.x, -canvas.height/2 - cam.y);

 if(view === "angular") drawAngularGrid();
 else drawTopGrid();

 requestAnimationFrame(render);
}
render();

canvas.addEventListener("wheel", e=>{
 e.preventDefault();
 cam.zoom = Math.max(.5, Math.min(3, cam.zoom + (e.deltaY>0?-0.1:0.1)));
},{passive:false});

let panning=false, last={x:0,y:0};
canvas.addEventListener("pointerdown", e=>{
 panning=true; last={x:e.clientX,y:e.clientY};
});
canvas.addEventListener("pointermove", e=>{
 if(panning){
  cam.x += (last.x - e.clientX)/cam.zoom;
  cam.y += (last.y - e.clientY)/cam.zoom;
  last={x:e.clientX,y:e.clientY};
 }
});
canvas.addEventListener("pointerup", ()=>panning=false);
canvas.addEventListener("pointerleave", ()=>panning=false);
</script>
</body>
</html>
